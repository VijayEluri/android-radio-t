buildscript {
  repositories {
    mavenCentral()
    jcenter()
  }

  dependencies {
    classpath 'org.hidetake:gradle-ssh-plugin:0.3.0'
    classpath 'com.bmuschko:gradle-vagrant-plugin:2.0'
    classpath 'com.bmuschko:gradle-docker-plugin:2.3.1'
  }
}

apply plugin: 'scala'
apply plugin: 'application'
apply plugin: 'ssh'
apply plugin: 'com.bmuschko.vagrant-base'
apply plugin: 'com.bmuschko.docker-java-application'


import com.bmuschko.gradle.vagrant.tasks.VagrantUp
import com.bmuschko.gradle.vagrant.tasks.VagrantSsh


version = '1.0'

//noinspection GroovyUnusedAssignment
mainClassName = 'ServerStarter'

repositories {
  mavenCentral()
}

ssh {
  knownHosts = allowAnyHosts
}

remotes {
  local {
    host = 'localhost'
    port = 2222
    user = 'vagrant'
    identity = new File('.vagrant/machines/local/virtualbox/private_key')
  }

  production {
    host = '188.166.29.129'
    user = 'root'
    identity = new File('~/.ssh/id_rsa')
  }
}

docker {
  javaApplication {
    baseImage = 'java:7-jre'
    maintainer = 'Sergey Moshnikov <apps-dandelion@gmail.com>'
    port = 80
    group = 'sergeymo'
  }
}

dockerDistTar {
  runCommand "echo Europe/Helsinki > /etc/timezone && dpkg-reconfigure tzdata --frontend noninteractive"
}

task uberjar(type: Jar, dependsOn: 'classes') {
  from files(sourceSets.main.output.classesDir)
  from files(sourceSets.main.output.resourcesDir)
  from { configurations.compile.collect { zipTree(it) } }
}

task localUp(type: VagrantUp) {
  description = "Start local Vagrant box"
}

dockerBuildImage {
  dependsOn localUp
}

task vagrantProductionUp(type: VagrantUp) {
  commands << 'radio-t-server'
  provider = 'digital_ocean'
}

task deployLocal(type: VagrantSsh, dependsOn: ['localUp', 'dockerBuildImage']) {
  description = 'Deploys the server to the local Vagrant environment'

  sshCommand = "/vagrant/docker/local/run-server.sh"
}

task deployProduction(dependsOn: ['uberjar', 'vagrantProductionUp']) {
  description = 'Deploys the server to the production environment'
  doLast { deployApp(remotes.production) }
}

task checkProduction {
  description = "Check the production installation"
  doLast {
    def topic =  "http://radiot.tindandelion.com:8080/api/chat/v1/topic".toURL().text
    logger.info "Production server is responding, current topic is: [$topic]"
  }
}


private void deployApp(def remote) {
  def tempPath = '/tmp/' + uberjar.archiveName
  def distributionDir = '/opt/radio-t-server'

  sshexec {
    session(remote) {
      put(uberjar.archivePath.absolutePath, tempPath)
      executeSudo("mv $tempPath $distributionDir")
      executeSudo("rm -f /var/log/radio-t-server/*")
      executeSudo("/etc/init.d/radio-t-server restart")
    }
  }
}

dependencies {
  compile 'org.scala-lang:scala-compiler:2.11.1'
  compile 'org.scala-lang:scala-library:2.11.1'
  compile 'org.scalatra:scalatra_2.11:2.3.0'
  compile 'org.scalatra:scalatra-json_2.11:2.3.0'
  compile 'org.json4s:json4s-jackson_2.11:3.2.10'
  compile 'org.eclipse.jetty:jetty-webapp:9.1.4.v20140401'
  compile 'ch.qos.logback:logback-classic:1.1.1'
  compile 'ch.qos.logback:logback-access:1.1.1'

  compile files('libs/smack-3.4.1-0cec571.jar', 'libs/smackx-3.4.1-0cec571.jar')
  testCompile 'org.scalatra:scalatra-scalatest_2.11:2.3.0'
}